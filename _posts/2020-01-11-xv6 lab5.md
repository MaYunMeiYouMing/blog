---
layout: post
title:  "6.828 Lab 5: File system, Spawn and Shell"
date:   2020-01-11 17:12:01 +0800
categories: OS
tag: xv6
---

* content
{:toc}

>本文为原创

## 磁盘上的文件系统结构

大多数UNIX文件系统将可用磁盘空间分为两种主要区域类型：inode区域和数据区域。 UNIX文件系统为文件系统中的每个文件分配一个索引节点。文件的inode包含有关文件的关键元数据，例如其stat属性和指向其数据块的指针。数据区域被分成许多数据块（通常为8KB或更大），文件系统在其中存储文件数据和目录元数据。目录条目包含文件名和指向inode的指针。如果文件系统中的多个目录条目引用该文件的inode，则该文件被称为`hard-linked`。由于我们的文件系统将不支持硬链接，因此我们不需要这种间接连接，因此可以简化以下操作：我们的文件系统不使用索引节点，而只会存储文件（或子目录）的（唯一的）目录条目中描述所有内容。

文件和目录在逻辑上都由一系列数据块组成，这些数据块可能分散在整个磁盘上，就像环境的虚拟地址空间的页面可以分散在整个物理内存中一样。文件系统环境隐藏了块布局的细节，提供了用于在文件内任意位置读取和写入字节序列的接口。文件系统环境在内部处理对目录的所有修改，这是执行诸如创建和删除文件之类的操作的一部分。我们的文件系统确实允许用户环境直接读取目录元数据（例如，通过`read`），这意味着用户环境可以自己执行目录扫描操作（例如，执行`ls`程序），而不必依赖于对文件系统的特殊调用。它使得在不改变应用程序或者重新编译应用程序的情况下，很难更改文件系统的内部布局，这是目录扫描方法的缺点，也是大多数现代UNIX的变体不鼓励这样做的原因。

### 扇区和块

大多数磁盘无法以字节为单位执行读取和写入，而是以扇区为单位执行读取和写入。在JOS中，每个扇区均为512字节。文件系统实际上以块为单位分配和使用磁盘存储。注意两个术语之间的区别：扇区大小是磁盘硬件的属性，而块大小是使用磁盘的操作系统的一个方面。文件系统的块大小必须是磁盘的扇区大小的倍数。

UNIX xv6文件系统使用512字节的块大小，与磁盘的扇区大小相同。因为存储空间变得便宜得多了，并且以较大的粒度管理存储更加有效，所以大多数现代文件系统使用更大的块大小。我们的文件系统将使用4096字节的块大小，可以方便地匹配处理器的页面大小。

### 超级块

文件系统通常在磁盘的`易于查找的`位置（例如最开始或结尾）保留某些块，以保存描述整个文件系统属性（例如块大小）的元数据，磁盘大小，查找根目录所需的任何元数据，上次安装文件系统的时间，上次检查文件系统的错误的时间等等。这些特殊的块称为超级块。

我们的文件系统将只有一个超级块，该超级块将始终位于磁盘上的块1中。其布局由`inc/fs.h`中的`struct Super`定义。块0通常被保留以容纳引导加载程序和分区表，因此文件系统通常不使用第一个磁盘块。许多`实际的`文件系统维护了多个超级块，这些超级块存放在磁盘的多个间隔较大的区域，存放着相同的数据。因此，如果其中一个损坏或磁盘在该区域中出现介质错误，仍可以找到其他超级块并将其用于访问文件系统。

![]({{ '/styles/images/2020-01-11-xv6 lab5/01.png' | prepend: site.baseurl}})

### 文件元数据

`inc/fs.h`中的`struct File`描述我们的文件系统中的元数据的布局。此元数据包括文件的名称，大小，类型（常规文件或目录），以及指向组成文件的块的指针。如上所述，我们没有inode，因此此元数据存储在磁盘上的目录条目中。与大多数的文件系统不同，为简单起见，我们将使用一种`File`结构来表示文件元数据，因为它同时出现在磁盘和内存中。

`struct File`中的`f_direct`数组包含用于存储文件的前10个（NDIRECT）块的块号的空间，我们将其称为文件的直接块。对于大小不超过10 * 4096 = 40KB的小文件，这意味着该文件所有块的块号将直接适合于File结构本身。但是，对于较大的文件，我们需要一个地方来容纳文件的其余块编号。因此，对于任何大于40KB的文件，我们分配一个额外的磁盘块，称为文件的间接块，以容纳4096/4 = 1024个额外的块号。因此，我们的文件系统允许文件的大小最大为1034块，刚好超过4M字节。为了支持更大的文件，`实际`文件系统通常还支持双重和三重间接块。

![]({{ '/styles/images/2020-01-11-xv6 lab5/02.png' | prepend: site.baseurl}})

### 目录文件与普通文件

我们文件系统中的`File`结构可以代表常规文件或目录； 这两种类型的文件可以通过`文件`结构中的`type`字段来区分。文件系统以完全相同的方式管理普通文件和目录文件，只是它根本不解释与普通文件相关联的数据块的内容，而文件系统将目录文件的内容解释为一系列描述目录中文件和子目录的`File`结构。

我们文件系统中的超级块包含一个`File`结构（`struct Super`中的根字段），其中包含文件系统根目录的元数据。该目录文件的内容是一系列`File`结构，描述了位于文件系统根目录中的文件和目录。根目录中的任何子目录都可能包含更多表示子子目录的File结构，依此类推。

## 磁盘访问

操作系统中的文件系统环境需要能够访问磁盘，但是我们尚未在内核中实现任何磁盘访问功能。我们没有采取将IDE磁盘驱动程序以及允许文件系统访问内核的系统调用添加到内核的这种常规`整体`操作系统策略，而是将IDE磁盘驱动程序实现为用户级文件系统环境的一部分。我们仍然需要稍微修改内核，以便进行设置，方便文件系统环境实现磁盘访问本身所需的特权。

只要我们依靠轮询，以及基于`编程I/O`（PIO）的磁盘访问并且不使用磁盘中断，就可以轻松的在用户空间中实现磁盘访问。也可以在用户模式下实现中断驱动设备的驱动程序（例如L3和L4内核执行此操作），但由于内核必须现场中断设备并将其分派到正确的用户模式环境，因此更加困难。

x86处理器使用EFLAGS寄存器中的IOPL位来确定是否允许保护模式代码执行特殊的设备I/O指令，例如IN和OUT指令。由于我们需要访问的所有IDE磁盘寄存器都位于x86的`I/O`空间中，而不是位于内存映射中，因此，我们唯一需要做的就是为文件系统环境赋予`I/O特权`。允许文件系统访问这些寄存器。实际上，EFLAGS寄存器中的IOPL位为内核提供了一种简单的"all-or-nothing"方法，用于控制用户模式代码是否可以访问I/O空间。在我们的情况下，我们希望文件系统环境能够访问I/O空间，但是我们根本不希望任何其他环境能够访问I/O空间。

### Exercise 1

`i386_init`通过将`ENV_TYPE_FS`类型传递给你的环境创建函数`env_create`来标识文件系统环境。在`env.c`中修改`env_create`，以便它赋予文件系统环境I/O特权，但绝不将该特权赋予任何其他环境。

`kern/env.c env_create`的代码如下：
```
void
env_create(uint8_t *binary, enum EnvType type)
{
    // LAB 3: Your code here.
    struct Env *e;
    int r = env_alloc(&e, 0);
    if (r)
        panic("env_alloc: %e", r);
    load_icode(e, binary);
    e->env_type = type;

	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.
	if(type == ENV_TYPE_FS)
		e->env_tf.tf_eflags |= FL_IOPL_MASK;

}
```

确保可以启动文件环境而不会引起`General Protection`错误。你应该能通过`fs i/o`测试。

### Question 1

当你随后从一种环境切换到另一种环境时，是否还需要执行其他操作以确保正确保存和还原此I/O特权设置？为什么？

答案是不需要，因为切换环境需要保存当前环境的硬件上下文并且恢复下一个环境的硬件上下文。

请注意，本实验中的`GNUmakefile`文件将QEMU设置为与以前一样，将文件`obj/kern/kernel.img`用作磁盘0（通常在`DOS/Windows`下为`Drive C`）的映像，并使用（新）文件`obj/fs/fs.img`作为磁盘1（`Drive D`）的​​映像。在本实验中，我们的文件系统只能接触磁盘1；磁盘0仅用于引导内核。如果想以某种方式损坏任何一个磁盘映像，则只需键入以下命令，即可将它们都重置为其“原始”版本：

```
$ rm obj/kern/kernel.img obj/fs/fs.img
$ make
```

或通过执行以下操作：

```
$ make clean
$ make
```

## 块缓存

在我们的文件系统中，我们将借助处理器的虚拟内存系统实现一个简单的`buffer cache`（实际上只是一个块缓存）。块缓存的代码在`fs/bc.c`中。

我们的文件系统将只能处理3GB或更小的磁盘。我们在文件系统环境的地址空间为磁盘的`内存映射`保留了固定的3GB区域，从0x10000000（`DISKMAP`）到0xD0000000（`DISKMAP + DISKMAX`）。例如，磁盘块0映射到虚拟地址0x10000000，磁盘块1映射到虚拟地址0x10001000，依此类推。`fs/bc.c`中的`diskaddr`函数实现了从磁盘块号到虚拟地址的转换（以及一些完整性检查）。

由于我们的文件系统环境具有自己的虚拟地址空间，而与系统中其他的环境的虚拟地址空间无关，并且文件系统环境唯一需要做的就是实现文件访问，因此以这种方式保留大多数文件系统环境的地址空间是合理的。由于现代磁盘大于3GB，因此在32位计算机上执行实际文件系统会很尴尬。在具有64位地址空间的计算机上，这种缓冲区高速缓存管理方法可能仍然是合理的。

当然，将整个磁盘读入内存将花费很长时间，因此，我们将实现一种需求分页的形式，其中我们仅在磁盘映射区域中分配页面，并响应页面错误而从磁盘中读取相应的块。该区域中的，这样，我们可以假装整个磁盘都在内存中。

### Exercise 2

在`fs/bc.c`中实现`bc_pgfault`和`flush_block`函数。`bc_pgfault`是一个页面错误处理程序，就像你在上一个实验中为实现写时复制实现的页面处理程序一样，不同之处在于`bc_pgfault`的工作是响应页面错误并从磁盘加载页面。编写此代码时，请记住，（1）`addr`可能未与块边界对齐，并且（2）`ide_read`是以扇区为单位操作而不是以块为单位操作。

必要时，`flush_block`函数应将一个块写入到磁盘。如果该块甚至不在块缓存中（即页面未映射）或它没有设置脏位，则`flush_block`不应执行任何操作。我们将使用VM硬件来跟踪上一次对磁盘的操作是否修改了磁盘块。要查看某个块是否需要写入，我们可以看看是否在uvpt条目中设置了`PTE_D`“dirty”位。 （PTE_D位由处理器根据对该页面的写入进行设置；请参见386参考手册[第5章](http://pdos.csail.mit.edu/6.828/2011/readings/i386/s05_02.htm)中的5.2.4.3。）将块写入磁盘后，`flush_block`应使用`sys_page_map`清除`PTE_D`位。

·fs/bc.c bc_pgfault`的代码如下：

```
	// LAB 5: you code here:
	addr = (void*) ROUNDDOWN(addr, PGSIZE);
	if((r = sys_page_alloc(0, addr, PTE_U | PTE_W | PTE_P)) < 0)
		panic("In bc_pgfault, sys_page_alloc: %e", r);
	if((r = ide_read(blockno * 8, addr, 8)) < 0)
		panic("In bc_pgfault, ide_read: %e", r);
```

`fs/bc.c flush_block`的代码如下：

```
void
flush_block(void *addr)
{
	uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;

	if (addr < (void*)DISKMAP || addr >= (void*)(DISKMAP + DISKSIZE))
		panic("flush_block of bad va %08x", addr);

	// LAB 5: Your code here.
	//panic("flush_block not implemented");
	addr = (void*)ROUNDDOWN(addr, PGSIZE);
	if(va_is_mapped(addr) == false)
		return;
	if (va_is_dirty(addr) == false)
		return;
	int r;
	if((r = ide_write(blockno * 8, addr, 8)) < 0)
		panic("In flush_block, ide_write: %e", r);
	if ((r = sys_page_map(0, addr, 0, addr, PTE_SYSCALL)) < 0)
		panic("In flush_block, sys_page_map: %e", r);
	
}
```

使用`make grade`测试你的代码。你的代码应通过`check_bc`，`check_super`和`check_bitmap`。

`fs/fs.c`中的`fs_init`函数是例子，告诉我们如何使用块缓存。初始化块高速缓存后，它仅将指针存储到全局变量`super`中的磁盘映射区域中。此后，我们可以简单地从`super`中读取它们，就像它们在内存中一样，并且页面错误处理程序将根据需要从磁盘中读取它们。

## The Block Bitmap

在`fs_init`设置了`bitmap`指针之后，我们可以将`bitmap`视为位的打包数组，磁盘上每个块一个。参见，例如，`block_is_free`，其仅检查在位图中是否将给定块标记为空闲。

### Exercise 3

使用`free_block`作为模型在`fs/fs.c`中实现`alloc_block`，后者应在位图中找到可用的磁盘块，将其标记为已使用，然后返回该块的编号。分配块时，应立即使用`flush_block`将更改后的位图块刷新到磁盘，以帮助文件系统保持一致。



使用`make grade`测试你的代码。你的代码现在应该能通过`alloc_block`。