---
layout: post
title:  "6.828的lab2实验"
date:   2019-06-30 16:01:01 +0800
categories: OS
tag: xv6
---

* content
{:toc}

>本文为原创

在entry.S中，将页目录表`entry_pgdir`存放入cr3寄存器。

```
	movl	$(RELOC(entry_pgdir)), %eax
f0100015:	b8 00 30 11 00       	mov    $0x113000,%eax
	movl	%eax, %cr3
f010001a:	0f 22 d8             	mov    %eax,%cr3
```

## Exercise 1

首先分析`boot_alloc()`函数的作用.这个函数是进行第一个页分配.如果这个函数分配虚拟内存成功,就会返回一个空闲内存的地址.其中的ROUNDUP()函数会将n计算成一个大于或等于PGSIZE，且是PGSIZE的倍数的值.`end`指向的是第一个未使用的虚拟内存地址,也是内核的末尾地址.

再看我们要写的代码的注释:分配一个n大小的内存,由于xv6内存页都是固定的所以需要使用ROUNDUP()函数分配分配一个大于n且是PGSIZE的倍数的内存.并且在n参数是0时,返回NULL值.

这时jos启动时，jos的kerninfo命令的结果：

```
Special kernel symbols:
  _start                  0010000c (phys)
  entry  f010000c (virt)  0010000c (phys)
  etext  f0102879 (virt)  00102879 (phys)
  edata  f0116060 (virt)  00116060 (phys)
  end    f01166a0 (virt)  001166a0 (phys)
Kernel executable memory footprint: 90KB
```

代码如下:

```
    result = nextfree;
	nextfree += ROUNDUP(n, PGSIZE);
	return result;
```

分析mem_init()的注释:分配一个`npages * sizeof(struct PageInfo)`大小的内存给`pages`,然后将pages的内存段初始化为0.pages是记录物理页的状态.

代码如下:
```
pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));
memset(pages, 0, npages * sizeof(struct PageInfo));
```

分析page_init()函数,在这个函数初始化物理内存页后,boot_alloc()函数将不再使用。除了将物理内存页0和IO hole区域开始到内核结束的区域置为已使用外,以及用于存放kern_pgdir和pages的区域，其他的是未使用。由于boot_alloc函数分配的地址是与`end`相连接的，所以这块区域的开始页码是`IOPHYSMEM/PGSIZE`,结束页码是`ROUNDUP(0)/PGSIZE`,`ROUNDUP(0)`返回已经使用的内存的结尾地址。

代码如下:

```
	size_t i;
	for (i = 0; i < npages; i++) {
		if(i == 0) {
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
		} else if(i * PGSIZE >= IOPHYSMEM && i * PGSIZE <= PADDR(boot_alloc(0))) {
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
		} else {
			pages[i].pp_ref = 0;
			pages[i].pp_link = page_free_list;
			page_free_list = &pages[i];
		}
	}
```

分析page_alloc()函数,其中可以通过page2kva()函数，将struct PageInfo的指针地址转换成虚拟地址。page_free_list会存放空闲列表的头节点

代码如下:

```
	// Fill this function in
	if(page_free_list == NULL)
	    return NULL;
	struct PageInfo* result = page_free_list;
	page_free_list = result->pp_link;
	if (alloc_flags & ALLOC_ZERO) {
		memset(page2kva(result), 0, PGSIZE);
	}
	result->pp_ref = 0;
	result->pp_link = NULL;
	return result;
```

分析page_free()函数

代码如下:

```
	if(pp->pp_ref != 0 || pp->pp_link != NULL)
	    panic("You can't free this page");
	pp->pp_link = page_free_list;
	pp->pp_ref = 0;
	page_free_list = pp;
```

## Exercise 4

分析pgdir_walk()函数,

代码如下:

```
	pde_t *pg_dir_entry = NULL;
	pte_t *pg_tbl_entry = NULL;
	struct PageInfo *page_info = NULL;
	
	pg_dir_entry = pgdir+PDX(va);

	if (*pg_dir_entry & PTE_P)
		return (pte_t *)KADDR(PTE_ADDR(*pg_dir_entry)) + PTX(va);

	if (create) {
		page_info = page_alloc(0);	
		if (page_info == NULL)
			return NULL;

		memset(page2kva(page_info), 0, PGSIZE);
		page_info->pp_ref ++;					
		pg_tbl_entry = (pte_t *)page2kva(page_info);		
		*pg_dir_entry = PADDR(pg_tbl_entry) | PTE_P | PTE_U | PTE_W;
		return pg_tbl_entry+PTX(va);
	}

	return NULL;
```