---
layout: post
title:  "6.828的lec1实验"
date:   2019-06-18 18:38:01 +0800
categories: OS
tag: xv6
---

* content
{:toc}


>本文为原创

## PC物理地址空间

```
	+------------------+  <- 0xFFFFFFFF (4GB)
	|      32-bit      |
	|  memory mapped   |
	|     devices      |
	|                  |
	/\/\/\/\/\/\/\/\/\/\

	/\/\/\/\/\/\/\/\/\/\
	|                  |
	|      Unused      |
	|                  |
	+------------------+  <- depends on amount of RAM
	|                  |
	|                  |
	| Extended Memory  |
	|                  |
	|                  |
	+------------------+  <- 0x00100000 (1MB)
	|     BIOS ROM     |
	+------------------+  <- 0x000F0000 (960KB)
	|  16-bit devices, |
	|  expansion ROMs  |
	+------------------+  <- 0x000C0000 (768KB)
	|   VGA Display    |
	+------------------+  <- 0x000A0000 (640KB)
	|                  |
	|    Low Memory    |
	|                  |
	+------------------+  <- 0x00000000
```

第一代基于16位Intel 8088处理器的PC仅能够使用1MB的物理内存。因此，早期PC的物理地址空间将从0x00000000开始，到0x000FFFFF结束，而不是0xFFFFFFFF。标有“Low Memory”的640KB区域是早期PC可以使用的唯一的随机存取存储器（RAM）; 事实上，最早的PC只能配置16KB，32KB或64KB的RAM！

从0x000A0000到0x000FFFFF的384KB区域由硬件保留用于特殊用途，例如视频显示缓冲区和固件的非易失性存储。这些保留区域最重要的部分是BIOS，它占用了从0x000F0000到0x000FFFFF的64KB区域。早期的PC把BIOS保存在真正的只读存储器（ROM）中，但是现在的PC将BIOS存储在可更新的闪存中。BIOS负责执行基本的系统初始化，例如激活显卡和检查安装的内存容量。执行此初始化后，BIOS从某些适当的位置（如软盘，硬盘，CD-ROM或网络）加载操作系统，并将机器的控制权交给操作系统。

Intel的80286和80386处理器突破了1Mb的内存大小，并且它们分别支持16MB和4GB物理地址空间的，但是仍然保留了原有的低1MB物理地址空间布局，以确保向后兼容软件。因此，现代PC在物理内存中有一个“空洞”，从0x000A0000到0x00100000，它将RAM分为两个部分，一个是“Low”或着叫作“conventional memory”，这一块就是内存起始的前640KB，另一个是“extended memory”（其他所有剩余容量）。此外，PC的32位物理地址空间顶部的一些空间，通常由BIOS保留，供32位PCI设备使用。

## 实模式

在实模式下，内存被限制为仅一兆字节（220字节）。 有效地址范围是（十六进制）00000至FFFFF。 这些地址需要一个20位数字。 显然，8086的任何16位寄存器都无法容纳20位数字。 英特尔通过使用两个16位值确定一个地址来解决此问题。 第一个16位值称为selector。selector的值必须存储在段寄存器中。 第二个16位值称为offset。 由一对32位的`selector：offset`来引用的物理地址，物理地址由以下公式计算

```
16 ∗ selector + offset
```

用十六进制乘以16很容易，只需在数字的右边添加一个0。例如，由047C：0048引用的物理地址由下式给出：

```
  047C0
  +0048
————————
  04808
```

实际上，selector的值是一个段落号

这个分段地址有以下缺点：

+ 一个selector的值只能引用64K内存（16位偏移的限制）。 如果程序有64K以上的代码？ CS寄存器中的值就不能用于该程序的整个执行。 该程序必须分为几个部分（称为段），每个部分的大小小于64K。 当执行从一个段移到另一个段时，必须更改CS的值。 类似问题
在有大量数据和DS寄存器中发生。

+ 内存中的每个字节没有唯一的分段地址。物理地址04808可以由047C：0048、047D：0038、047E：0028或047B：0058引用。 这会使分段地址的比较变复杂。

## 16位保护模式

在80286的16位保护模式下，selector的值的解释与实模式完全不同。在实模式下，selector的值是物理内存的段落编号。 在保护模式下，selector的值是描述符表的索引。在两种模式下，程序都是被分为几个部分。在实模式下，这些段位于物理内存中的固定位置
，selector的值表示该段的开头的段落编号。在保护模式下，段不是在物理内存中的固定位置。实际上，段不一定在内存中！

保护模式使用一种虚拟内存的技术。基本思路虚拟内存系统的功能是仅将正在运行的程序的数据和代码保留在内存中，而其他数据和代码被临时存储在磁盘上，直到再次运行它们为止。

在16位保护模式下，段会根据需要在内存和磁盘之间移动。段从磁盘存储返回到内存时，很有可能会将其放置在其他区域。所有这些都由操作系统完成。

在保护模式下，在描述符表中为每个段分配了一个条目。这个条目具有系统需要知道的段的所有信息。该信息包括：当前是否在内存中；
如果在内存中，它在哪里；访问权限（例如，只读）。 selector的值就是用于在描述符表中寻找条目的索引值。

16位保护模式的一大缺点是偏移量仍为16位。 结果，段大小仍然限制为最大64K。 这使得使用大型阵列成为问题！

## 32位保护模式

80386引入了32位保护模式。386 32位和286 16位保护模式之间有两个主要区别：

1. 偏移量扩展为32位。这允许偏移范围扩大到40亿。 因此，段的最大大小为4 GB。

2. 段可以被分成大小为4K的页。虚拟内存系统现在可以处理页面而不是段。
这意味着，在任何时间里，一个段可能只有一部分在内存中。在286的16位模式下，整个段都在内存中或都不在。对于32位的较大段，这是不切实际的。  

## Boot Loader

BIOS将启动扇区加载到物理地址0x7c00至0x7dff这个区间。在6.828中,boot loader 主要完成两个工作，一个是将实模式转换到保护模式，一个是加载jos内核。

1. 将寄存器 cr0 的第一位为1置为1,即可开启保护模式,主要代码如下:

```
.set CR0_PE_ON,      0x1         # protected mode enable flag
```

```
lgdt    gdtdesc
movl    %cr0, %eax
orl     $CR0_PE_ON, %eax
movl    %eax, %cr0
```

2. 加载内核的第一步是,将 kernel 加载到一个page中,这个page是4k的大小,而且有一个elf格式的结构体指针(ELFHDR)指向这个page的首地址.
```
#define ELFHDR		((struct Elf *) 0x10000) // scratch space
```

```
// read 1st page off disk (4k)
readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);
```

然后根据魔数判断kernel的elf格式是否正确.接下来将根据ELFHDR指针的`e_phoff`找到program header table的首地址,然后根据table中的条目加载相应的程序.

主要代码如下:

```
// load each program segment (ignores ph flags),e_phoff(program header table offset)
ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
eph = ph + ELFHDR->e_phnum;
for (; ph < eph; ph++)
	// p_pa is the load address of this segment (as well
	// as the physical address)
	readseg(ph->p_pa, ph->p_memsz, ph->p_offset);
```

## port2

### Exercise 3
```
1. At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?
```
解答:

在执行完`movl    %eax, %cr0`之后,保护模式被开启,32-bit的code就可以执行了,cr0寄存器的第一位置为1,就是开启了保护模式. 

```
2. What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?
```
解答:

`call   *0x10018`是boot loader执行的最后的代码。可以通过查看boot loader反编译的`boot.asm`得到.

`movw   $0x1234,0x472`是内核执行的第一行代码。

分析：

`objdump -x obj/kern/kernel`

反汇编内核代码，可以直接查看内核的第一行代码的位置，然后在`0x10000c`处设置断点，运行到此处即可得到内核的第一行代码

```
3. Where is the first instruction of the kernel?
```
解答:

内核的第一条指令的物理地址为0x10000c

```
4. How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?
```
解答:

elf header 中有提供内核大小


### Exercise 4

解答:

数组的地址是由低到高的，并且数据存储时，是数据的低位存低位地址。


### Exercise 5

解答:

将Makefrag文件中的-Ttext的参数修改为0x7c01，然后再调试，会发现qemu在反复读取内核。


### Exercise 6

解答:

![]({{ '/styles/images/2019-06-17-6.828 lec1/01.png' | prepend: site.baseurl }})

从图中可以看出，这是一个从无到有的过程。(注意：在设置断点的时候使用的是物理地址不是虚拟地址，因为这个时候页表还未开启。在kernel.asm文件中的是虚拟地址，在这个地址上减去0xf0000000即可得到物理地址)

## port3

### Exercise 7

解答:

![]({{ '/styles/images/2019-06-17-6.828 lec1/02.png' | prepend: site.baseurl }})

因为`movl %eax,%cr0`会开启页表，所以在没有执行这条指令的时候，0xf0100000处是没有内容的，而0x00100000处有内容。当执行这条指令后，页表开启，虚拟高地址将映射到物理低地址，所以0xf0100000和0x00100000处的内容相同，因为，虚拟低地址同样会映射到物理低地址。

如果注释掉，结果很明显，0xf0100000处是没有内容的。

### Exercise 8

实验开始前,先来一波分析.

I/O分析:
`int	cprintf(const char *fmt, ...);`这是`inc/stdio.h`中定义的输出函数,函数cprintf在`kern/print.c`中实现,代码如下:

```
int
cprintf(const char *fmt, ...)
{
	va_list ap;
	int cnt;

	va_start(ap, fmt);
	cnt = vcprintf(fmt, ap);
	va_end(ap);

	return cnt;
}
```
这段代码中会调用三个函数`va_start`,`vcprintf`和`va_end`,其中`va_start`和`va_end`是在`inc/stdarg.h`在定义的,具体可以参考[这里](https://www.cnblogs.com/pengdonglin137/p/3345911.html).vcprintf函数是在`kern/print.c`中实现的,vcprintf代码实现如下:

```
int
vcprintf(const char *fmt, va_list ap)
{
	int cnt = 0;

	vprintfmt((void*)putch, &cnt, fmt, ap);
	return cnt;
}
```

很明显,cnt是用来计量实际输出字符的,然后调用`lib/printfmt.c`中定义的vprintfmt函数来实现输出数据格式化,然后在vprintfmt函数内部调用`printnum`函数,`printnum`函数又调用`putch`函数,然后`putch`函数经过一系列复杂的过程将数据输出.

实验开始:

这部分有点神奇,刚开始的时候没有什么思路,但在printfmt.c中发现十进制和十六进制的代码非常相似,所以八进制输出代码就这样写出来了.

```
case 'o':
			// Replace this with your code.
			num = getuint(&ap, lflag);
			base = 8;
			goto number;
```

Be able to answer the following questions:

```
1. Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?
```
解答:

console.c对外暴露的函数是cputchar

为什么 `/lib/printfmt.c `这个文件是放在/lib/目录下的。我认为这是对输出的一个高度抽象,其中的各个部分可以被重复利用.

```
2.　Explain the following from console.c:
1      if (crt_pos >= CRT_SIZE) {
2              int i;
3              memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
4              for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
5                      crt_buf[i] = 0x0700 | ' ';
6              crt_pos -= CRT_COLS;
7      }
```
解答:

首先,我们从`kern/console.c`的cga_putc函数中分析出,crt_pos是指向输出窗口缓冲区的最后一个数据的位置,而CRT_SIZE是指向整个输出窗口缓冲区的大小.这段代码当在窗口缓冲区溢出时,进行相应的处理.

`memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));`它会把 crt_buf+CRT_COLS开始的， (CRT_SIZE-CRT_COLS)\*size 个字节的内存，移动到crt_buf位置。

```
for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
    crt_buf[i] = 0x0700 | ' ';
```
这段代码将[CRT_SIZE - CRT_COLS,CRT_SIZE]中的缓冲区置0.

```
3. For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC's calling convention on the x86.
Trace the execution of the following code step-by-step:

int x = 1, y = 3, z = 4;
cprintf("x %d, y %x, z %d\n", x, y, z);

In the call to cprintf(), to what does fmt point? To what does ap point?

List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments.
```
解答:

fmt指向格式化字符串"x %d, y %x, z %d\n"的内存地址，ap指向第一个要打印的参数的内存地址，也就是x的地址。

这个可以通过直接阅读源码得出结果,也可以参考[这里](https://jiyou.github.io/blog/2018/04/15/mit.6.828/jos-lab1/)

```
4. Run the following code.
    unsigned int i = 0x00646c72;
    cprintf("H%x Wo%s", 57616, &i);
What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?

Here's a description of little- and big-endian and a more whimsical description.
```
解答:

输出为hello world.这个可以通过直接阅读源码得出结果,也可以参考[这里](https://www.cnblogs.com/wuhualong/p/lab01_exercise08_formatted_printing_to_the_console.html)

```
5. In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?
    cprintf("x=%d y=%d", 3);
```
解答:

这种栈越界操作，其实是无法判定的。因为不知道越界这个内存里面以前放的内容是什么。

```
6. Let's say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?
```

这个可以通过直接阅读源码得出结果,也可以参考[这里](https://www.cnblogs.com/wuhualong/p/lab01_exercise08_formatted_printing_to_the_console.html),他提供了两种方法,第一种我不是很明白.

```
Challenge Enhance the console to allow text to be printed in different colors. The traditional way to do this is to make it interpret ANSI escape sequences embedded in the text strings printed to the console, but you may use any mechanism you like. There is plenty of information on the 6.828 reference page and elsewhere on the web on programming the VGA display hardware. If you're feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer.
```
不会!!!

### Exercise 9

```
Exercise 9. Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which "end" of this reserved area is the stack pointer initialized to point to?
```
解答:

通过查看boot.asm文件,可以看出,栈指针的初始位置

![]({{ '/styles/images/2019-06-17-6.828 lec1/03.png' | prepend: site.baseurl }})

查看kernel.asm文件,可以看出虚拟内存位置为0xf0100035,实际物理地址为0x100035

![]({{ '/styles/images/2019-06-17-6.828 lec1/04.png' | prepend: site.baseurl }})

### Exercise 10

```
Exercise 10. To become familiar with the C calling conventions on the x86, find the address of the test_backtrace function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of test_backtrace push on the stack, and what are those words?

Note that, for this exercise to work properly, you should be using the patched version of QEMU available on the tools page or on Athena. Otherwise, you'll have to manually translate all breakpoint and memory addresses to linear addresses.
```
解答:

gdb调试可以参考[这里](https://wizardforcel.gitbooks.io/100-gdb-tips/print-registers.html).实验可以参考[这里](https://www.cnblogs.com/wuhualong/p/lab01_exercise10_test_backtrace.html).

这是gdb调试结果(test_backtrace(5))

![]({{ '/styles/images/2019-06-17-6.828 lec1/05.png' | prepend: site.baseurl }})

### Exercise 11

```
Exercise 11. Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn't. After you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like.

If you use read_ebp(), note that GCC may generate "optimized" code that calls read_ebp() before mon_backtrace()'s function prologue, which results in an incomplete stack trace (the stack frame of the most recent function call is missing). While we have tried to disable optimizations that cause this reordering, you may want to examine the assembly of mon_backtrace() and make sure the call to read_ebp() is happening after the function prologue.
```
解答:

由于ebp寄存器是上一个栈的栈顶的内存地址,即esp的值.而每个函数开头的指令`push %ebp`等价于
```
subl $4, %esp

movl %ebp (%esp)
```

`movl %esp,%ebp`会将当前的栈顶存于ebp寄存器中,所以可以通过ebp来获取栈中元素.

这是根据汇编规则绘制的函数调用的栈帧:

![]({{ '/styles/images/2019-06-17-6.828 lec1/07.png' | prepend: site.baseurl }})

每个test_backtrace函数的调用会创建一个相同的栈.

```
args[4]
args[3]
args[2]
args[1]
args[0]
eip
ebp
```
所以可以根据这个写这样的代码(我抄的).
```
cprintf("Stace backtrace:\n");
	uint32_t *ebp = (uint32_t *)read_ebp();

	while (ebp){
		cprintf("ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,ebp[1],ebp[2],ebp[3],ebp[4],ebp[5],ebp[6],ebp[7]);
		ebp = (uint32_t *)*ebp;
	}
```

### Exercise 12

解答:

是否有加载符号表,可以在内核进入点0x10000c处设置断点.然后使用命令`x/8s stabstr_begin`可以查看,stab_begin是你的stabstr段的开始地址,stabstr段的开始地址可以使用命令` objdump -h obj/kern/kernel`查看,stabstr段的VMA的值就是开始地址,我的操作如下:

![]({{ '/styles/images/2019-06-17-6.828 lec1/06.png' | prepend: site.baseurl }})

由于这个时候还没有开启虚拟内存页,所以只能使用物理地址.从图中可以看出已经加载了符号表.

这一题有点复杂,可以参考[这里](https://www.cnblogs.com/wuhualong/p/lab01_exercise12_print_more_info.html)

最后强烈推荐[这个](https://www.cnblogs.com/wuhualong/p/mit_6-828_lab1.html)

[xv6 lab1 学习](http://www.voidcn.com/article/p-otgxarrw-ro.html)

