---
layout: post
title:  "6.828 Lab 6: Network Driver"
date:   2020-01-30 12:07:01 +0800
categories: OS
tag: xv6
---

* content
{:toc}

>本文为原创

在本练习中，将为网卡编写驱动程序。该卡将基于Intel 82540EM芯片，也称为E1000。

但是，网卡驱动程序不足以使OS连接到Internet。在新的lab6代码中，提供了网络堆栈和网络服务器。

除了编写驱动程序之外，还需要创建一个系统调用接口来授予对驱动程序的访问权限。将实现网络服务器，以在网络堆栈和驱动程序之间传输数据包。还将通过完成Web服务器将所有内容捆绑在一起。

# QEMU的虚拟网络

因为它不需要运行任何管理权限，所以使用QEMU的用户模式网络堆栈。QEMU的文档在[这里](http://wiki.qemu.org/download/qemu-doc.html#Using-the-user-mode-network-stack)有更多关于用户网络的信息。我们已经更新了makefile，以启用QEMU的用户模式网络堆栈和虚拟E1000网卡。

默认情况下，QEMU提供运行在IP 10.0.2.2上的虚拟路由器，并将为JOS分配IP地址10.0.2.15。为简单起见，我们将这些默认值直接到`net/ns.h`中。

虽然QEMU的虚拟网络允许JOS连接连接到Internet，但JOS的10.0.2.15地址在QEMU内部运行的虚拟网络的外部没有任何意义（即QEMU充当NAT），因此我们无法直接连接到服务器即使在运行QEMU的主机中，也可以在JOS内部运行。为了解决这个问题，我们将QEMU配置为在主机上某个端口上运行服务器，该服务器仅连接到JOS中的某个端口，并在真实主机和虚拟网络之间来回穿梭数据。

你将在端口7（echo）和80（http）上运行JOS服务器。为避免在共享的Athena机器上发生冲突，makefile会根据你的用户ID为这些机器生成转发端口。要查明QEMU​​转发到开发主机上的端口，请运行`make which-ports`。为了方便起见，makefile还提供了`make nc-7`和`make nc-80`，这使你可以直接与在终端中这些端口上运行的服务器进行交互。（这些目标仅连接到正在运行的QEMU实例；你必须单独启动QEMU本身。）

## Packet Inspection

makefile还配置QEMU的网络堆栈，以将所有传入和传出数据包记录到你的目录中的`qemu.pcap`。

要获取捕获的数据包的十六进制/ASCII转储，请使用`tcpdump`，如下所示：

```
tcpdump -XXnr qemu.pcap
```

或者，可以使用Wireshark检查pcap文件。 Wireshark还知道如何解码和检查数百种网络协议。如果你使用的是Athena，则必须使用Wireshark的前身ethereal

## 调试E1000

我们很幸运能够使用仿真硬件。由于E1000在软件中运行，因此仿真的E1000可以以用户可读的格式向我们报告其内部状态以及遇到的任何问题。通常，使用裸机编写驱动程序的开发人员将无法获得这种奢侈。

E1000可以产生很多调试输出，因此你必须启用特定的日志记录通道。你可能会发现有用的一些渠道是：

```

Flag        Meaning
tx          Log packet transmit operations
txerr	    Log transmit ring errors
rx          Log changes to RCTL
rxfilter    Log filtering of incoming packets
rxerr	    Log receive ring errors
unknown	    Log reads and writes of unknown registers
eeprom	    Log reads from the EEPROM
interrupt   Log interrupts and changes to interrupt registers.
```

例如，要启用`tx`和`txerr`日志记录，请使用`make E1000_DEBUG=tx,txerr ...`。

注意：E1000_DEBUG标志仅在6.828版本的QEMU中起作用。

你可以进一步使用软件仿真的硬件进行调试。如果你陷入困境，并且不了解E1000为什么没有按预期方式做出响应，则可以在`hw/net/e1000.c`中查看QEMU的E1000实现。

# 网络服务器

从头开始编写网络堆栈是一项艰巨的工作。我们将使用lwIP，这是一个开源的轻量级TCP/IP协议套件，其中包括一个网络堆栈。你可以在[此处](https://savannah.nongnu.org/projects/lwip/)找到有关lwIP的更多信息。就我们而言，lwIP是一个黑箱，它实现了BSD套接字接口，并具有一个数据包输入端口和一个数据包输出端口。

网络服务器实际上是四个环境的组合：
+ 核心网络服务器环境（包括套接字调用分派器和lwIP）
+ 输入环境
+ 输出环境
+ 计时器环境

下图显示了不同的环境及其关系。该图显示了包括设备驱动程序在内的整个系统，稍后将进行介绍。在本实验中，你将实现以绿色突出显示的部分。

![]({{ '/styles/images/2020-02-01-xv6 lab6/01.png' | prepend: site.baseurl}})

## 核心网络服务器环境

核心网络服务器环境由套接字调用分派器和lwIP本身组成。套接字调用调度程序的工作方式与文件服务器完全相同。用户环境使用stubs（在`lib/nsipc.c`中找到）将IPC消息发送到核心网络环境。如果查看`lib/nsipc.c`，你会发现核心网络服务器与文件服务器相同：`i386_init`使用`NS_TYPE_NS`创建了NS环境，因此我们扫描envs，寻找这种特殊的环境类型。对于每个用户环境IPC，网络服务器中的调度程序代表用户调用lwIP提供的相应BSD套接字接口功能。

常规用户环境不直接使用`nsipc_ *`调用。相反，它们使用`lib/sockets.c`中的函数，该函数提供了基于文件描述符的套接字API。因此，用户环境通过文件描述符引用套接字，就像它们引用磁盘文件一样。许多操作（connect, accept等）特定于套接字，但是read，write和close都是通过`lib/fd.c`中的常规文件描述符设备分配代码进行。就像文件服务器为所有打开的文件维护内部唯一ID的方式一样，lwIP还会为所有打开的套接字生成唯一的ID。在文件服务器和网络服务器中，我们都使用存储在`struct Fd`中的信息将每个环境的文件描述符映射到这些唯一的ID空间。

即使文件服务器和网络服务器的IPC调度程序看起来似乎相同，也存在关键区别。诸如accept和recv之类的BSD套接字调用可以无限期地阻塞。如果调度程序要让lwIP执行这些阻塞调用之一，则调度程序也将阻塞，并且整个系统一次只能有一个未完成的网络调用。由于这是不可接受的，因此网络服务器使用用户级线程来避免阻塞整个服务器环境。对于每个传入的IPC消息，调度程序都会创建一个线程并在新创建的线程中处理请求。如果线程阻塞，则只有该线程进入睡眠状态，而其他线程继续运行。

除了核心网络环境外，还有三个辅助环境。除了接受来自用户应用程序的消息外，核心网络环境的调度程序还接受来自输入和计时器环境的消息。

## 输出环境

为用户环境套接字提供服务时，lwIP将生成数据包供网卡传输。lwIP将使用`NSREQ_OUTPUT` IPC消息将每个要发送的数据包发送到输出辅助环境，并将该数据包附加在IPC消息的page参数中。输出环境负责接受这些消息，并通过即将创建的系统调用接口将数据包转发到设备驱动程序。

## 输入环境

网卡收到的数据包需要注入到lwIP。对于设备驱动程序收到的每个数据包，输入环境（使用你将实现的内核系统调用）将数据包送到内核空间，然后使用`NSREQ_INPUT` IPC消息将数据包发送到核心服务器环境。

数据包输入功能与核心网络环境分开，因为JOS使其难以同时接受IPC消息以及轮询或等待来自设备驱动程序的数据包。在JOS中，我们没有`select`系统调用，该调用将允许环境监视多个输入源以标识准备好处理哪些输入。

如果看一下`net/input.c`和`net/output.c`，你会发现两者都需要实现。这主要是因为实现取决于你的系统调用接口。在实现驱动程序和系统调用接口之后，将为两个辅助环境编写代码。

## 计时器环境

计时器环境会定期向核心网络服务器发送`NSREQ_TIMER`类型的消息，通知其计时器已超时。lwIP使用此线程的计时器消息来实现各种网络定时。

## Part A: 初始化和发送数据包

你的内核没有时间概念，因此我们需要设置它。当前，硬件每10毫秒产生一次时钟中断。在每次时钟中断处，都给变量增加一，以指示时间过去了10ms。这是在`kern/time.c`中实现的，但尚未完全集成到你的内核中。

### Exercise 1

在`kern/trap.c`中为时钟中断添加一个对`time_tick`的调用。实现`sys_time_msec`并将其添加到`kern/syscall.c`中的`syscall`中，以便用户可以获取时间。

```
    if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
        lapic_eoi();
		time_tick(); //在lab4的基础上增加
        sched_yield();
        return;
    }
```

syscall:

```
case SYS_time_msec:
    ret = sys_time_msec();
    break;
```

`sys_time_msec`的代码如下：

```
static int
sys_time_msec(void)
{
    return time_msec();
}
```

使用`make INIT_CFLAGS=-DTEST_NO_NS run-testtime-nox`来测试你的代码。你应该看到环境从1秒间隔的5开始倒数。`-DTEST_NO_NS`禁用启动网络服务器环境，因为它会在这个实验中此时出现错误。

# 网卡

编写驱动程序需要深入了解硬件和提供给软件的接口。该实验文本将提供有关如何与E1000进行交互的高级概述，但是你在编写驱动程序时需要充分利用Intel的手册。

### Exercise 2

浏览E1000的英特尔[软件开发人员手册](https://pdos.csail.mit.edu/6.828/2018/readings/hardware/8254x_GBe_SDM.pdf)。本手册涵盖了几个紧密相关的以太网控制器。QEMU模拟82540EM。

你现在应该浏览第二章，以了解该设备。要编写驱动程序，你需要熟悉第3章和第14章以及4.1（尽管不是4.1的小节）。你还需要参考第13章。其他章节主要介绍你的驱动程序不需要与之交互的E1000组件。现在不用担心细节了；只是了解文档的结构，以便以后查找。

阅读手册时，请记住E1000是具有许多高级功能的复杂设备。有效的E1000驱动程序仅需要NIC提供的部分功能和接口。请仔细考虑连接网卡的最简单方法。强烈建议你先使用基本驱动程序，然后再使用高级功能。

## PCI接口

E1000是PCI设备，这意味着它已插入主板上的PCI总线。PCI总线具有地址，数据和中断线，并允许CPU与PCI设备进行通信，并且PCI设备可以读写内存。在使用PCI设备之前，需要先找到这些设备并初始化。通过遍历PCI总线以查找连接的设备。初始化是分配I/O和内存空间以及协商设备要使用的IRQ线的过程。

我们在`kern/pci.c`中为你提供了PCI代码。要在引导过程中执行PCI初始化，PCI代码将遍历PCI总线以查找设备。找到设备后，它将读取其供应商ID和设备ID，并使用这两个值作为关键字来搜索`pci_attach_vendor`数组。该数组由`struct pci_driver`条目组成，如下所示：

```
struct pci_driver {
    uint32_t key1, key2;
    int (*attachfn) (struct pci_func *pcif);
};
```

如果被发现的设备的供应商ID和设备ID与阵列中的条目匹配，则PCI代码将调用该条目的`attachfn`来执行设备初始化。（设备也可以通过类来标识，这是`kern/pci.c`中其他驱动程序表的作用。）

Attach函数通过PCI函数进行初始化。尽管E1000仅提供一种功能，但PCI卡可以提供多种功能。这是我们在JOS中表示PCI功能的方式：

```
struct pci_func {
    struct pci_bus *bus;

    uint32_t dev;
    uint32_t func;

    uint32_t dev_id;
    uint32_t dev_class;

    uint32_t reg_base[6];
    uint32_t reg_size[6];
    uint8_t irq_line;
};
```

以上结构反映了开发人员手册第4.1节表4-1中的某些条目。`struct pci_func`的最后三个条目记录了设备的协商内存，I/O和中断资源。`reg_base`和`reg_size`数组包含最多六个基地址寄存器或BAR的信息。`reg_base`存储内存映射的I/O区域（或I/O端口资源的基本I/O端口）的基本内存地址，`reg_size`包含`reg_base`中相应基本值的字节大小或I/O端口数，`irq_line`包含分配给设备进行中断的IRQ线。 E1000 BAR的具体含义在表4-2的后半部分给出。

调用设备的附加功能时，已找到该设备但尚未启用。这意味着PCI代码尚未确定分配给设备的资源，例如地址空间和IRQ线，因为尚未填充`struct pci_func`结构的最后三个元素。Attach函数应调用`pci_func_enable`，它将启用设备，协商这些资源并填充`struct pci_func`。

### Exercise 3

实现附加功能以初始化E1000。如果找到匹配的PCI设备，则在`kern/pci.c`中的`pci_attach_vendor`数组中添加一个条目，以触发你的功能（请确保将其放在标记表末尾的{0，0，0}条目之前）。你可以在5.2节中找到QEMU模拟的82540EM的供应商ID和设备ID。当启动时JOS扫描PCI总线时，你也应该看到这些内容。

现在，只需通过pci_func_enable启用E1000设备。在整个实验中，我们将添加更多初始化设置。

我们为你提供了`kern/e1000.c`和`kern/e1000.h`文件，这样你就无需弄乱构建系统。它们目前为空；你需要填写它们来完成这个练习。你可能还需要在内核的其他位置引入`e1000.h`文件。



引导内核时，你应该看到它显示E1000卡的PCI功能已启用。你的代码现在应该通过了`make grade`的`pci attach`测试。