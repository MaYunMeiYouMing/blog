---
layout: post
title:  "6.828 Lab 6: Network Driver"
date:   2020-01-30 12:07:01 +0800
categories: OS
tag: xv6
---

* content
{:toc}

>本文为原创

在本练习中，将为网卡编写驱动程序。该卡将基于Intel 82540EM芯片，也称为E1000。

但是，网卡驱动程序不足以使OS连接到Internet。在新的lab6代码中，提供了网络堆栈和网络服务器。

除了编写驱动程序之外，还需要创建一个系统调用接口来授予对驱动程序的访问权限。将实现网络服务器，以在网络堆栈和驱动程序之间传输数据包。还将通过完成Web服务器将所有内容捆绑在一起。

# QEMU的虚拟网络

因为它不需要运行任何管理权限，所以使用QEMU的用户模式网络堆栈。QEMU的文档在[这里](http://wiki.qemu.org/download/qemu-doc.html#Using-the-user-mode-network-stack)有更多关于用户网络的信息。我们已经更新了makefile，以启用QEMU的用户模式网络堆栈和虚拟E1000网卡。

默认情况下，QEMU提供运行在IP 10.0.2.2上的虚拟路由器，并将为JOS分配IP地址10.0.2.15。为简单起见，我们将这些默认值直接到`net/ns.h`中。

虽然QEMU的虚拟网络允许JOS连接连接到Internet，但JOS的10.0.2.15地址在QEMU内部运行的虚拟网络的外部没有任何意义（即QEMU充当NAT），因此我们无法直接连接到服务器即使在运行QEMU的主机中，也可以在JOS内部运行。为了解决这个问题，我们将QEMU配置为在主机上某个端口上运行服务器，该服务器仅连接到JOS中的某个端口，并在真实主机和虚拟网络之间来回穿梭数据。

你将在端口7（echo）和80（http）上运行JOS服务器。为避免在共享的Athena机器上发生冲突，makefile会根据你的用户ID为这些机器生成转发端口。要查明QEMU​​转发到开发主机上的端口，请运行`make which-ports`。为了方便起见，makefile还提供了`make nc-7`和`make nc-80`，这使你可以直接与在终端中这些端口上运行的服务器进行交互。（这些目标仅连接到正在运行的QEMU实例；你必须单独启动QEMU本身。）

## Packet Inspection

makefile还配置QEMU的网络堆栈，以将所有传入和传出数据包记录到你的目录中的`qemu.pcap`。

要获取捕获的数据包的十六进制/ASCII转储，请使用`tcpdump`，如下所示：

```
tcpdump -XXnr qemu.pcap
```

或者，可以使用Wireshark检查pcap文件。 Wireshark还知道如何解码和检查数百种网络协议。如果你使用的是Athena，则必须使用Wireshark的前身ethereal

## 调试E1000

我们很幸运能够使用仿真硬件。由于E1000在软件中运行，因此仿真的E1000可以以用户可读的格式向我们报告其内部状态以及遇到的任何问题。通常，使用裸机编写驱动程序的开发人员将无法获得这种奢侈。

E1000可以产生很多调试输出，因此你必须启用特定的日志记录通道。你可能会发现有用的一些渠道是：

```

Flag        Meaning
tx          Log packet transmit operations
txerr	    Log transmit ring errors
rx          Log changes to RCTL
rxfilter    Log filtering of incoming packets
rxerr	    Log receive ring errors
unknown	    Log reads and writes of unknown registers
eeprom	    Log reads from the EEPROM
interrupt   Log interrupts and changes to interrupt registers.
```

例如，要启用`tx`和`txerr`日志记录，请使用`make E1000_DEBUG=tx,txerr ...`。

注意：E1000_DEBUG标志仅在6.828版本的QEMU中起作用。

你可以进一步使用软件仿真的硬件进行调试。如果你陷入困境，并且不了解E1000为什么没有按预期方式做出响应，则可以在`hw/net/e1000.c`中查看QEMU的E1000实现。

# 网络服务器

从头开始编写网络堆栈是一项艰巨的工作。我们将使用lwIP，这是一个开源的轻量级TCP/IP协议套件，其中包括一个网络堆栈。你可以在[此处](https://savannah.nongnu.org/projects/lwip/)找到有关lwIP的更多信息。就我们而言，lwIP是一个黑箱，它实现了BSD套接字接口，并具有一个数据包输入端口和一个数据包输出端口。

网络服务器实际上是四个环境的组合：
+ 核心网络服务器环境（包括套接字调用分派器和lwIP）
+ 输入环境
+ 输出环境
+ 计时器环境

下图显示了不同的环境及其关系。该图显示了包括设备驱动程序在内的整个系统，稍后将进行介绍。在本实验中，你将实现以绿色突出显示的部分。

![]({{ '/styles/images/2020-02-01-xv6 lab6/01.png' | prepend: site.baseurl}})

## 核心网络服务器环境

核心网络服务器环境由套接字调用分派器和lwIP本身组成。套接字调用调度程序的工作方式与文件服务器完全相同。用户环境使用stubs（在`lib/nsipc.c`中找到）将IPC消息发送到核心网络环境。如果查看`lib/nsipc.c`，你会发现核心网络服务器与文件服务器相同：`i386_init`使用`NS_TYPE_NS`创建了NS环境，因此我们扫描envs，寻找这种特殊的环境类型。对于每个用户环境IPC，网络服务器中的调度程序代表用户调用lwIP提供的相应BSD套接字接口功能。

常规用户环境不直接使用`nsipc_ *`调用。相反，它们使用`lib/sockets.c`中的函数，该函数提供了基于文件描述符的套接字API。因此，用户环境通过文件描述符引用套接字，就像它们引用磁盘文件一样。许多操作（connect, accept等）特定于套接字，但是read，write和close都是通过`lib/fd.c`中的常规文件描述符设备分配代码进行。就像文件服务器为所有打开的文件维护内部唯一ID的方式一样，lwIP还会为所有打开的套接字生成唯一的ID。在文件服务器和网络服务器中，我们都使用存储在`struct Fd`中的信息将每个环境的文件描述符映射到这些唯一的ID空间。

即使文件服务器和网络服务器的IPC调度程序看起来似乎相同，也存在关键区别。诸如accept和recv之类的BSD套接字调用可以无限期地阻塞。如果调度程序要让lwIP执行这些阻塞调用之一，则调度程序也将阻塞，并且整个系统一次只能有一个未完成的网络调用。由于这是不可接受的，因此网络服务器使用用户级线程来避免阻塞整个服务器环境。对于每个传入的IPC消息，调度程序都会创建一个线程并在新创建的线程中处理请求。如果线程阻塞，则只有该线程进入睡眠状态，而其他线程继续运行。

除了核心网络环境外，还有三个帮助程序环境。除了接受来自用户应用程序的消息外，核心网络环境的调度程序还接受来自输入和计时器环境的消息。