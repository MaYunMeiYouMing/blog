---
layout: post
title:  "G1 全解"
date:   2019-11-16 22:11:01 +0800
categories: jvm
tag: Java
---

* content
{:toc}

### G1

Garbage-First（G1）垃圾收集器是一种面向服务器的垃圾收集器，适用于具有大内存的多处理器计算机。它试图以高概率满足垃圾收集（GC）暂停时间目标，同时实现高吞吐量。全堆操作（例如全局标记）与应用程序线程同时执行。这样可以防止与堆或活动数据大小成比例的中断。

G1收集器通过多种技术实现了高性能和暂停时间目标。

堆被划分为一组大小相等的堆区域，每个堆区域都有一个连续的虚拟内存范围。G1执行并发全局标记阶段，以确定整个堆中对象的活动性。标记阶段完成后，G1知道哪些区域大部分为空。它首先收集这些区域，这通常会产生大量的自由空间。这就是为什么这种垃圾收集方法称为“垃圾优先”的原因。顾名思义，G1将其收集和压缩活动集中在可能充满可回收对象（即垃圾）的堆区域。G1使用暂停预测模型满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择要收集的区域数。

G1将对象从堆的一个或多个区域复制到堆上的单个区域，并在此过程中压缩并释放内存。撤离是在多处理器上并行执行的，以减少暂停时间并增加吞吐量。因此，对于每个垃圾回收，G1都会不断减少碎片。这超出了先前两种方法的能力。CMS（并发标记扫描）垃圾收集不会进行压缩。并行压缩仅执行整堆压缩，这会导致相当长的暂停时间。

重要的是要注意，G1不是实时收集器。它很有可能达到设定的暂停时间目标，但并非绝对确定。根据先前收集的数据，G1估计在目标时间内可以收集多少个区域。因此，收集器具有收集区域成本的合理准确的模型，并且收集器使用此模型来确定要收集哪些和多少区域同时停留在暂停时间目标内。

G1的首要重点是为运行需要大堆且GC延迟有限的应用程序的用户提供解决方案。这意味着堆大小约为6 GB或更大，并且稳定且可预测的暂停时间低于0.5秒。

如果应用程序具有以下一个或多个特征，那么今天运行CMS或并行压缩的应用程序将从切换到G1中受益。

超过50％的Java堆被实时数据占用。

对象分配率或提升率差异很大。

该应用程序正在经历不希望的长时间垃圾收集或压缩暂停（长于0.5到1秒）。

计划将G1作为并发标记扫描收集器（CMS）的长期替代产品。将G1与CMS进行比较，可以发现使G1成为更好解决方案的差异。一个区别是G1是压紧收集器。同样，G1提供的垃圾收集暂停比CMS收集器更具可预测性，并允许用户指定所需的暂停目标。

与CMS一样，G1专为需要较短GC暂停的应用而设计。

G1将堆划分为固定大小的区域（灰色框），如图9-1“按G1 进行堆划分”所示。

图9-1按G1进行堆划分

如下图9-1所示

![]({{ '/styles/images/2019-11-16-G1/01.jpg' | prepend: site.baseurl}})

“图9-1通过G1进行堆划分”的描述

从逻辑上讲，G1是世代相传的。一组空区域被指定为逻辑年轻代。在图中，年轻一代是浅蓝色的。分配工作是从逻辑上年轻的一代中进行的，当年轻一代已满时，该区域集将被垃圾收集（一个年轻的集合）。在某些情况下，可以同时收集一组年轻区域之外的区域（深蓝色的旧区域）。这称为混合集合。在图中，正在收集的区域用红色框标记。该图说明了混合的收集，因为同时收集了年轻区域和旧区域。垃圾收集是一个压缩收集，它将活动对象复制到选定的最初为空的区域。根据幸存对象的年龄，可以将对象复制到幸存者区域（标有“ S”）或复制到旧区域（未具体显示）。标有“ H”的区域包含的绒毛物体大于一个区域的一半，并且经过特殊处理；请参见了Humongous对象和分配了Humongous在垃圾-First垃圾收集。

分配（疏散）失败
与CMS一样，G1收集器会在应用程序继续运行时运行其部分收集，并且存在应用程序分配对象的速度快于垃圾收集器可以回收可用空间的风险。请参见并发模式失败的并发标记扫描（CMS）收集的类似CMS行为。在G1中，当G1将活动数据从一个区域复制（撤离）到另一个区域时，发生故障（Java堆耗尽）。复制是为了压缩实时数据。如果在撤离正在收集垃圾的区域时找不到空闲（空）区域，则会发生分配失败（因为没有空间来从正在撤离的区域分配有生命的物体），并停止世界活动（ STW）已完成完整收集。

浮动垃圾
对象可能在G1收集期间死亡，无法收集。G1使用一种称为快照快照（SATB）的技术来确保垃圾收集器找到所有活动对象。SATB指出，出于收集的目的，在并发标记（整个堆上的标记）开始时处于活动状态的任何对象都被视为处于活动状态。SATB以类似于CMS增量更新的方式允许浮动垃圾。

暂停
G1暂停应用程序以将活动对象复制到新区域。这些暂停可以是仅收集年轻区域的年轻收集暂停，也可以是疏散年轻和旧区域的混合收集暂停。与CMS一样，在应用程序停止时，有一个最终标记或备注暂停以完成标记。CMS还具有初始标记暂停，而G1则作为疏散暂停的一部分进行初始标记工作。G1在集合的结尾具有清理阶段，该阶段部分为STW，部分为并发。清理阶段的STW部分标识空区域，并确定旧区域作为下一个集合的候选对象。

卡表和并发阶段
如果垃圾收集器没有收集整个堆（增量收集），则垃圾收集器需要知道从堆的未收集部分到正在收集的堆部分的指针在哪里。这通常用于分代垃圾回收器，其中堆的未收集部分通常是旧的一代，而堆的收集部分是年轻的一代。用于保存此信息的数据结构（指向年轻一代对象的老一代指针）是一个可记忆的集合。甲卡表是一个特定类型的记录置位的。Java HotSpot VM使用字节数组作为卡表。每个字节称为卡。卡与堆中的地址范围相对应。对卡进行脏污意味着将字节的值改为脏值 ; 脏值可能会在卡所覆盖的地址范围内包含从旧一代到年轻一代的新指针。

处理卡意味着查看卡，看是否有老一代指向年轻一代的指针，并可能对该信息进行某些处理，例如将其传输到另一个数据结构。

G1具有并发标记阶段，该阶段标记从应用程序中找到的活动对象。并发标记从疏散暂停（完成初始标记工作）结束到标记为止。并发清理阶段将集合清空的区域添加到空闲区域列表中，并清除记住的那些区域集。另外，并发优化线程根据需要运行，以处理已被应用程序写入弄脏并且可能具有跨区域引用的卡表条目。

开始并发收集周期
如前所述，无论是旧区还是旧区，都是混合收集的垃圾。为了收集旧区域，G1对堆中的活动对象进行了完整的标记。这种标记是通过并发标记阶段完成的。当整个Java堆的占用达到参数的值时，开始并发标记阶段InitiatingHeapOccupancyPercent。使用命令行选项设置此参数的值-XX:InitiatingHeapOccupancyPercent=<NN>。默认值为InitiatingHeapOccupancyPercent45。

暂停时间目标
使用标记为G1设置暂停时间目标 MaxGCPauseMillis。G1使用预测模型来确定在该目标暂停时间内可以完成多少垃圾收集工作。在收集结束时，G1选择要在下一个收集（收集集）中收集的区域。集合集将包含年轻区域（其大小的总和决定逻辑年轻代的大小）。G1部分地通过选择集合集中的年轻区域的数量来控制GC暂停的长度。您可以与其他垃圾回收器一样，在命令行上指定年轻代的大小，但是这样做可能会妨碍G1达到目标暂停时间的能力。除了暂停时间目标之外，您还可以指定可能发生暂停的时间段的长度。您可以在此时间段内指定最小的变数用法（GCPauseIntervalMillis）以及暂停时间目标。默认值为MaxGCPauseMillis200毫秒。GCPauseIntervalMillis（0）的默认值等于时间跨度上没有要求。