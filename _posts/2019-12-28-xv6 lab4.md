---
layout: post
title:  "6.828的lab4实验"
date:   2019-12-28 21:31:01 +0800
categories: OS
tag: xv6
---

* content
{:toc}

>本文为原创

## Part A：多处理器支持和多任务协作

在本实验的第一部分，你需要扩展JOS以使其能在多处理器系统上运行，然后实现一些新的JOS内核系统调用，以允许用户级环境创建其他新环境（环境类似进程）。你还需要实现协作轮转调度(cooperative round-robin scheduling)，在当前环境自愿放弃CPU（或退出）时，允许内核从一种环境切换到另一种环境。在之后的C部分，您将实现抢占式调度，该调度使内核可以在经过一定时间后从环境重新获得对CPU的控制，即使环境不合作也是如此。

### 多处理器支持

JOS支持“对称多处理”（SMP），SMP是一种多处理器模型，其中所有CPU都具有对系统资源（例如内存和I / O总线）的同等访问权限。尽管所有CPU在SMP中在功能上都是相同的，但是在引导过程中，它们可以分为两种类型：引导处理器（BSP）负责初始化系统和引导操作系统；只有在操作系统启动并运行后，BSP才会激活应用程序处理器（AP）。BSP的处理器是由硬件和BIOS决定的。到目前为止，你现在所有的JOS代码都已在BSP上运行。

在SMP系统中，每个CPU都有一个local APIC（LAPIC）单元。LAPIC单元负责在整个系统中传递中断。LAPIC还为其连接的CPU提供唯一的标识符。在本实验中，我们利用LAPIC单元的以下基本功能（在kern/lapic.c中）：

+ 读取LAPIC标识符（APIC ID）以了解我们的代码当前在哪个CPU上运行（请参阅cpunum()）。

+ 从BSP发送启动处理器间中断（IPI）到AP以启动其他CPU（请参阅lapic_startap()）。

+ 在C部分中，我们对LAPIC的内置计时器进行编程，通过触发时钟中断来支持抢先式多任务处理（请参阅apic_init()）。

处理器使用内存映射的I/O（MMIO）访问其LAPIC。在MMIO中，一部分物理内存会直接存入某些I/O设备的寄存器，因此通常用于访问内存的相同加载/存储指令可使用设备寄存器访问。你已经在物理地址0xA0000上看到了一个IO区域（我们使用它来写入VGA显示缓冲区），输出缓冲区是0xf00b8000。LAPIC位于一个从物理地址0xFE000000（比4GB少32MB）开始的区域中，因此对于我们来说，直接映射在KERNBASE的空间很大。在JOS虚拟内存中映射了一个4MB空间的`MMIOBASE`，所以我们有地方映射这样的设备。由于以后的实验会介绍更多的MMIO区域，因此您需要编写一个简单的函数来从该区域分配空间并将设备内存映射到该区域。

#### Exercise 1

在`kern/pmap.c`中实现`mmio_map_region`。要了解其用法，请查看`kern/lapic.c`中`lapic_init`的开头。在运行mmio_map_region的测试之前，你也必须做下一个练习。

