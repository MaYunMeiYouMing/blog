---
layout: post
title:  "6.828的lab4实验"
date:   2019-12-28 21:31:01 +0800
categories: OS
tag: xv6
---

* content
{:toc}

>本文为原创

## Part A：多处理器支持和多任务协作

在本实验的第一部分，你需要扩展JOS以使其能在多处理器系统上运行，然后实现一些新的JOS内核系统调用，以允许用户级环境创建其他新环境（环境类似进程）。你还需要实现协作轮转调度(cooperative round-robin scheduling)，在当前环境自愿放弃CPU（或退出）时，允许内核从一种环境切换到另一种环境。在之后的C部分，您将实现抢占式调度，该调度使内核可以在经过一定时间后从环境重新获得对CPU的控制，即使环境不合作也是如此。

### 多处理器支持

JOS支持“symmetric multiprocessing”（SMP），SMP是一种多处理器模型，其中所有CPU都具有对系统资源（例如内存和I/O总线）的同等访问权限。尽管所有CPU在SMP中在功能上都是相同的，但是在引导过程中，它们可以分为两种类型：引导处理器（BSP）负责初始化系统和引导操作系统；只有在操作系统启动并运行后，BSP才会激活应用程序处理器（AP）。BSP的处理器是由硬件和BIOS决定的。到目前为止，你现在所有的JOS代码都已在BSP上运行。

在SMP系统中，每个CPU都有一个local APIC（LAPIC）单元。LAPIC单元负责在整个系统中传递中断。LAPIC还为其连接的CPU提供唯一的标识符。在本实验中，我们利用LAPIC单元的以下基本功能（在kern/lapic.c中）：

+ 读取LAPIC标识符（APIC ID）以了解我们的代码当前在哪个CPU上运行（请参阅cpunum()）。

+ 从BSP发送启动处理器间中断（IPI）到AP以启动其他CPU（请参阅lapic_startap()）。

+ 在C部分中，我们对LAPIC的内置计时器进行编程，通过触发时钟中断来支持抢先式多任务处理（请参阅apic_init()）。

处理器使用memory-mapped I/O (MMIO)访问其LAPIC。在MMIO中，一部分物理内存会直接存入某些I/O设备的寄存器，因此通常用于访问内存的相同加载/存储指令可使用设备寄存器访问。你已经在物理地址0xA0000上看到了一个IO区域（我们使用它来写入VGA显示缓冲区），输出缓冲区是0xf00b8000。LAPIC位于一个从地址0xFE000000（比4GB少32MB）开始的区域中，因此对于我们来说，直接映射到KERNBASE的空间很大。在JOS虚拟内存中映射了一个4MB空间的`MMIOBASE`，所以我们有地方映射这样的设备。由于以后的实验会介绍更多的MMIO区域，因此您需要编写一个简单的函数来从该区域分配空间并将设备内存映射到该区域。

#### Exercise 1

在`kern/pmap.c`中实现`mmio_map_region`。要了解其用法，请查看`kern/lapic.c`中`lapic_init`的开头。在运行mmio_map_region的测试之前，你也必须做下一个练习。

mmio_map_region的代码如下：

```
	size = ROUNDUP(size, PGSIZE);
	if((base + size > MMIOLIM) || (base + size < base))
		panic("Overflow in mmio region");
	boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);
	base += size; //base是全局变量，同时它将保存mmio中的可用空间的首地址
	return (void*)(base - size);
```

### Application Processor Bootstrap

在启动AP之前，BSP应该首先收集有关多处理器系统的信息，例如CPU的总数，它们的APIC ID和LAPIC单元的MMIO地址。`kern/mpconfig.c`中的`mp_init()`函数通过读取驻留在BIOS内存区域中的MP配置表来检索此信息。

`boot_aps()`函数(在`kern/init.c`中)驱动AP引导进程。AP在实模式下启动，就像引导加载程序在`boot/boot.S`中启动的方式一样，因此`boot_aps()`将AP入口代码(`kern/mpentry.S`)复制到可在实模式下寻址的内存位置。与引导加载程序不同，我们可以控制AP从何处开始执行代码。我们将代码复制到`0x7000`(`MPENTRY_PADDR`)，尽管在低位640KB的内存的任何未使用的，与页面对齐的物理地址都可以使用。

之后，`boot_aps()`通过向相应AP的LAPIC单元发送`STARTUP IPI`以及一个初始`CS:IP`地址来依次激活AP，并且AP应该从`MPENTRY_PADDR`处开始运行。`kern/mpentry.S`中的入口代码与`boot/boot.S`的入口代码非常相似。进行一些简单的设置后，它将使AP进入启用分页的保护模式，然后调用C设置例程`mp_main()`(也在`kern/init.c`中)。`boot_aps()`等待AP在其`struct CpuInfo`的cpu_status字段中发`CPU_STARTED`信号，然后再继续唤醒下一个。

#### Exercise 2

阅读`kern/init.c`中的`boot_aps()`和`mp_main()`，以及`kern/mpentry.S`中的汇编代码。确保您了解AP引导程序的控制流转换过程。然后在`kern/pmap.c`中修改您对`page_init()`的实现，以避免将`MPENTRY_PADDR`所在的页面被添加到空闲列表中，以便我们可以安全地在该物理地址复制并运行AP引导程序代码。你的代码应该能够通过被更新的`check_page_free_list()`的测试（但可能无法通过`check_kern_pgdir()`的测试）。

page_init应该修改为下面：

```
void
page_init(void)
{
	size_t i;
	for (i = 0; i < npages; i++) {
		if(i == 0) {
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
		} else if(i * PGSIZE >= IOPHYSMEM && i * PGSIZE <= PADDR(boot_alloc(0))) {
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
		} else if((struct PageInfo *)(&(pages[i])) == pa2page(MPENTRY_PADDR)) {  
            //这里是标记MPENTRY_PADDR所在的物理页
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
		} else {
			pages[i].pp_ref = 0;
			pages[i].pp_link = page_free_list;
			page_free_list = &pages[i];
		}
	}
}
```

#### Question 1

对比`kern/mpentry.S`与`boot/boot.S`。请记住，`kern/mpentry.S`就像内核中的所有其他内容一样经过编译和链接，在`KERNBASE`之上运行，宏`MPBOOTPHYS`的作用是什么？为什么在`kern/mpentry.S`中有必要，但在`boot/boot.S`中却没有？换句话说，如果在`kern/mpentry.S`中省略了它，那会出什么问题？

提示：回忆一下我们在实验1中讨论的链接地址和加载地址之间的区别。

通过响应来自启动CPU的STARTUP IPI信号，来启动每个非启动CPU(`AP`)。 AP将在实模式下启动，并将`CS:IP`设置为`XY00:0000`，其中XY是随STARTUP发送的8位值。 因此，此代码必须从4096字节边界开始。

因为此代码将DS设置为零，所以它必须从低2 ^ 16字节物理内存中的地址开始运行。

boot_aps()(在init.c中)将此代码复制到`MPENTRY_PADDR`(满足上述限制)。 然后，对于每个AP，它将预先分配的每个内核堆栈的地址存储在`mpentry_kstack`中，发送`STARTUP IPI`，并等待此代码确认它已启动(在init.c中的`mp_main`中发生)。

此代码类似于boot/boot.S，除了
+ 不需要启用A20
+ 它使用`MPBOOTPHYS`来计算其绝对地址
+ 依赖于符号，而不是依靠链接器填充它们

AP是从实模式下开始运行，所以需要通过 MPBOOTPHYS 宏的转换虚拟地址，运行这部分代码。boot.S 中不需要这个转换是因为代码的本来就被加载在实模式可以寻址的地方。

### 每个CPU的状态和初始化(Per-CPU State and Initialization)

编写多处理器OS时，区分每个处理器专用的CPU状态和整个系统共享的全局状态是非常重要的。`kern/cpu.h`定义了CPU的大多数状态，包括存储每个CPU变量的`struct CpuInfo`结构。`cpunum()`始终返回调用它的CPU的ID，该ID可用作`cpus`这样的数组的索引。 另外，宏`thiscpu`是当前CPU的`struct CpuInfo`的简写。

这是你应注意的CPU状态：

+	Per-CPU kernel stack.  
	由于多个CPU可以进入内核中，因此我们需要为每个处理器使用单独的内核堆栈，以防止它们干扰彼此的执行。数组`percpu_kstacks[NCPU][KSTKSIZE]`为NCPU的内核堆栈保留了空间。  
	
	在实验2中，你映射了BSP内核堆栈的物理内存`bootstack`，在`KSTACKTOP`的下方。 同样，在本实验中，您将把每个CPU的内核堆栈映射到该区域，其中保护页充当它们之间的缓冲区。 CPU 0的堆栈仍将从`KSTACKTOP`增长； CPU 1的堆栈将从CPU 0的堆栈底部开始的`KSTKGAP`字节后开始，依此类推。 `inc/memlayout.h`显示了映射布局。

+ Per-CPU TSS and TSS descriptor.
